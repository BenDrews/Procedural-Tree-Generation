                  <meta charset="utf-8">
                  **Report: Trees**
            Ben Drews, Diego Gonzalez, Lylia Li
            bfd2@williams.edu
            drg4@williams.edu
            ll5@williams.edu

![The beauty of computer graphics is that if you make one tree, you can make a forest of them.](evocativescene.png)


Introduction 
==================================
Our program procedurally generates tree models that are composed of cylinders connected to each other, with texture-mapped bark and leaves. Users can choose to generate trees using an L-system generation algorithm or a space colonization generation algorithm. Trees of different shapes and sizes can be generated by changing various parameters. Within the L-system generation algorithm, users can vary the recursion depth, initial height, number of circle points within each cylinder, number of branch sections, phenotype, and branch callback function of their trees. There is also an option to generate “autumn” trees with leaves that are red, orange, and yellow instead of green. Within the space colonization algorithm, users can vary the number of anchor points, height, radius, number of circle points within each cylinder, tree node distance, kill distance, branch initial radius, radius growth, attraction radius, leafiness, and discount rate of their trees. With all the different parameter options, a near infinite number of unique trees can be generated. Users have the additional option to generate an orchard with the tree models they create and grow different "fruit" from the trees.


Specification
==================================
**Features of the program:**

1. A user interface with the following tabs:
    1. L-system tab
        1. Recursion depth: Number of levels of recursion we will take our L-system through
        2. Initial height of tree
        3. Circle points: How round the cylinders that make up the tree will be
        4. Branch sections: How many cylindric sections are added to each branch
        5. Phenotype: What type of tree is generated
        6. Generate button to run the program
    2. Space colonization tab
        1. Anchor count: Number of initial anchor points
        2. Height: Total height of the tree
        3. Radius: Radius of the area the anchor points will be generated in
        4. Circle points: How round the cylinders that make up the tree will be
        5. Distance between tree nodes
        6. Kill distance for anchor nodes
        7. Initial branch tip radius: Each branch radius is defined by the radii of its children, so we add a parameter to specify the radius of a branch with no children
        8. Branch radius growth factor: Specific constant in definition of branch radius used by space colonization algorithm; higher constants lead to slower growth
        9. Attraction radius: Radius within which anchor points can attract nodes
        10. Leafiness
        11. Generate button to run the program
    3. Orchard tab
        1. Number of rows in the orchard
        2. Trees per row of orchard
        3. Generation type: Whether we are using L-system or space colonization trees
        4. Fruit type: Drop down list to choose which fruit the tree grows
        5. Generate button to run the program

2. In all tabs, when the "Generate" button is pressed, the program:
    1. Immediately displays a waiting screen
    2. Generates a tree/orchard with the specificed parameters
    3. Saves the generated model/scene to a file and loads the scene

3. L-system tree generation entry points
    1. method `App::makeLSkeleton()`: Generates a tree skeleton based on an L-system, with the parameters specified in the GUI
    2. method `App::skeletonToMeshL`: Converts the generated tree skeleton to an OBJ mesh

4. Space colonization tree generation entry points
    1. method `App::makeSCSkeleton()`: Generates a tree skeleton based on the space colonization algorithm, with the parameters specified in the GUI
    2. method `App::skeletonToMeshSC`: Converts the generated tree skeleton to an OBJ mesh

5. Orchard generation entry points
    1. method `App::generateOrchard()`: Generates a Scene.Any file containing an orchard of fruit trees with the parameters specified in the GUI

**Program evaluation metric:**

- Graph the time it took to render a tree model versus the number of child branches with a set recursion depth of 7

- Graph the time it took to render a tree model versus the recursion depth with three child branches at each recursion.

- **TODO:: ADD EVALUATION METRIC FOR SPACE COLONIZATION MODEL**


**Quality images:**
![An orchard with trees growing fruits, and small differences between trees to show variations within a single phenotype.](design4.jpg)

![A forest populated with different phenotypes of trees, to show variations between the trees our algorithm can generate.](specificationforest.png)

**Evocative result:**

![A fantasy scene of different planets being overgrown by different, arbitrarily large trees.](design5.jpg)


Topic Overview 
==================================
**Tree Generation using L-Systems**

L-systems provide an easy way to generate plantlike structures. Nature often encorporates fractal patterns in how plants grow and branch, which translates easily into recursive method calls which mirror such growth on a mesh (1).

![Fractals in Nature](plantFractal.png)

In order to set up this generation, a set of simple recusive rules must be written. These generally replace or grow a set of smaller branches off of a parent branch, and can be applied repeatedly to get increasingly detailed results.

![Products of L-Systems](L-SystemProducts.jpg)

**Tree Generation using Space Colonization**

Space Colonization is an algorithm that attempts to model the competition by branches for space on a tree in its generation. It does a better job than L-Systems at modeling mature trees, since as plant mature, the factors limiting their growth start to weigh more heavily on how branches are placed than the factors creating opportunites for growth (2).

![Tree generated with Space Colonization](SpaceColonizationTree.jpg)

The algorithm works by randomly seeding a volume with anchor points, which pull on tree nodes, spawning adjacent tree nodes in the average direction of the anchor points pulling on that node. Once a tree node gets too close to an anchor node, than anchor is destroyed. This process repeats until all anchors are destroyed.

![Space Colonization Iteration](SpaceColIter.jpg)


**Works Cited**

1. “L-system,” *Wikipedia*, accessed 19 Oct 2016. https://en.wikipedia.org/wiki/L-system

2. Adam Runions, Brendan Lane, and Przemyslaw Prusinkiewicz, “Modeling Trees with a Space Colonization Algorithm,” Eurographics Workshop on Natural Phenomena (2007). http://algorithmicbotany.org/papers/colonization.egwnp2007.pdf

Design
==================================

![](calldiagram.jpg)


**TODO:: ADD HYPERLINK TO DOXYGEN DOCUMENTATION**

**Major functions of App**
 Function             | Description                                                
 ---------------------|------------------------------------------------------------
 makeLTree            | Creates Meshes for a tree and the leaves of the tree, constructs an LGenerator to create the skeleton of the tree and write the skeleton to an OBJ file, handles logic of passing the right phenotype and branch callback function based on chosen parameters in GUI
 generateOrchard      | Generates and displays a Scene.Any file of multiple fruit trees based on the parameters in GUI
 customOrchard        | Generates the orchard used for our quality image
 generateForest       | Generates the forest used for our quality image


**Major functions of LGenerator**
 Function             | Description                                                
 ---------------------|------------------------------------------------------------
 makeLTreeSkeleton    | Makes a tree skeleton out of an L-system, defining where tree nodes are located
 skeletonToMeshL      | Takes tree skeleton produced by makeLTreeSkeleton and writes it to a Mesh class
 addLeaf / addLeaves  | Given a Mesh, adds two-sided triangle(s) to the Mesh
 addFruits            | Populates an array with Point3 locations of where fruits should be added in relation to the CoordinateFrame of the base of a tree
 addCylindricSection  | Given a Mesh and an initial circle, adds an additional circle to the mesh underneath the initial circle and adds faces between the circles


**Major functions of SCGenerator**
 Function             | Description                                                
 ---------------------|------------------------------------------------------------
 generateAnchorPoints | Returns a randomly distributed set of points inside the volume specified by the `envelopePerimeter` parameter
 addIntermediateAnchors| Generates a new set of anchors within the envelope and add them to the set of anchors
 findClosestNodes     |
 growTreeNodes        |
 killAnchors          |
 addCylindricSection  |
 addLeaf              | Given a Mesh, adds a two-sided triangle to the Mesh
 addFruits            | Populates an array with Point3 locations of where fruits should be added in relation to the CoordinateFrame of the base of a tree

 
 findClosestAnchor    | returns an array of the closest anchor points to each tree node that is within the radius of attraction
 findGrowthDirections | returns a map from the trees that have an anchor point within the radius of attraction to the average direction from that tree node to all anchors attracting it

**Major functions of Mesh**
 Function             | Description                                                
 ---------------------|------------------------------------------------------------
 addVertex            | Adds a vertex to the Mesh
 addFace              | Adds a face (three indices of the vertices array) to the Mesh
 numVertices          | Returns the size of the vertices array
 addMesh              | Adds a given Mesh to the end of the current Mesh
 toOFF                | Writes the Mesh to an OFF file
 toOBJ                | Writes the Mesh to an OBJ file

**Major functions of Face**
 Function             | Description                                                
 ---------------------|------------------------------------------------------------
 increment            | Increments all of the points of the face by a given number


We have two classes to handle our tree generation, LGenerator, which generates an L-system tree, and SCGenerator, which generates a space colonization tree.

Our program has four main functions: makeTree, makeBranch, addCylindricSection, and addLeaves. The makeTree function initializes the Meshes for the body of the tree and the leaves of the tree, and calls makeBranch to add cylinders to the Mesh. makeBranch is given a recursion depth that is decremented each time it is called. When the recursion depth is zero, it calls addLeaves to add leaves to the end of the current branch instead of constructing a new branch. addCylindricSection is a helper method for constructing cylinders that adds a circle underneath an initial circle. This design makes sense because we can see the initial parameters of the tree we are making by looking at the makeTree method call, and without having to see the details of how the tree is constructed in makeBranch. Also, this will allow us to have different makeBranch methods in order to generate trees of different phenotypes.

To handle the logic of adding vertices and faces to a Mesh and writing the Mesh to a file in OFF format, we used Ben’s Mesh class from the Meshes lab. A `Vector` of `Point3`s is used to store the vertices and a `Vector` of `SmallArray`s of three `int`s, is used to store the faces. We also added a Face class to Mesh, which stores all the information we need to know about the faces of a mesh, including its points as well as its texture points. By having these classes, we do not have to write OFF or OBJ files of generated trees directly in our App class, which would make things messy and bulky.


Correctness Results
==================================
demonstrating that the program is working as intended (or not), as dictated by your specification. These will probably be on very simple cases that can be hand-verified or are self-evidently correct. Explain why these are good and nearly-comprehensive tests. The results are frequently images in graphics projects, but may also be other forms of data.

![Wireframe of leafless tree to demonstrate proper branch generation](tree1.png)

The default parameters for the L-system tree are as follows:

1. Recursion Depth = 5
2. Phenotype = Normal
3. Spine Curve = Straight

![Recursion Depth: 5](RecursionDepth-5.png width=200 height=200) ![Recursion Depth: 6](RecursionDepth-6.png width=200 height=200) ![Recursion Depth: 7](RecursionDepth-7.png width=200 height=200)

![Phenotype: Random](Phenotype-Random.png width=200 height=200) ![Phenotype: Bush](Phenotype-Bush.png width=200 height=200) ![Phenotype: Pine](Phenotype-Pine.png width=200 height=200)

![Spine Curve: Curvy](SpineCurve-Curvy.png width=200 height=200) ![Spine Curve: Corkscrew](SpineCurve-Corkscrew.jpg width=200 height=200) ![Spine Curve: ](SpineCurve-Gentile.png width=200 height=200)

The default parameters for the space colonization tree are as follows:

1. Anchor Points = 1000
2. Tree Node Distance = 0.5
3. Kill Distance = 2
4. Initial Branch Radius = 0.01
5. Radius Growth Factor = 2
6. Attraction Radius = 100
7. Leafiness = 10
8. Discount Rate = 0.9
9. Envelope = Bulb

![Default Tree](Default-SC.jpg width=600)

These images show the effect of varying each parameter on the default tree:

![Anchor Points: 100](AnchorPoints-100.jpg width=200 height=200) ![Anchor Points: 500](AnchorPoints-500.jpg width=200 height=200) ![Anchor Points: 5000](AnchorPoints-5000.jpg width=200 height=200)

![Node Distance: 0.1](NodeDistance-0.1.jpg width=200 height=200) ![Node Distance: 0.25](NodeDistance-0.25.jpg width=200 height=200) ![Node Distance: 1](NodeDistance-1.jpg width=200 height=200)

![Kill Distance: 0.5](KillDistance-0.5.jpg width=200 height=200) ![Kill Distance: 1](KillDistance-1.jpg width=200 height=200) ![Kill Distance: 5](KillDistance-5.jpg width=200 height=200)

![Initial Radius: 0.025](InitialRadius-0.025.jpg width=200 height=200) ![Initial Radius: 0.05](InitialRadius-0.05.jpg width=200 height=200) ![Initial Radius: 0.1](InitialRadius-0.1.jpg width=200 height=200)

![Radius Growth Factor: 2.25](RadiusGrowthFactor-2.25.jpg width=200 height=200) ![Radius Growth Factor: 2.5](RadiusGrowthFactor-2.5.jpg width=200 height=200) ![Radius Growth Factor: 3](RadiusGrowthFactor-3.jpg width=200 height=200)

![Attraction Radius: 5](AttractionRadius-5.jpg width=200 height=200) ![Attraction Radius: 10](AttractionRadius-10.jpg width=200 height=200) ![Attraction Radius: 50](AttractionRadius-50.jpg width=200 height=200)

![Leafiness: 1](Leafiness-1.jpg width=200 height=200) ![Leafiness: 2](Leafiness-2.jpg width=200 height=200) ![Leafiness: 5](Leafiness-5.jpg width=200 height=200)

![Discount Rate: 0](DiscountRate-0.jpg width=200 height=200) ![Discount Rate: 0.25](DiscountRate-0.25.jpg width=200 height=200) ![Discount Rate: 0.5](DiscountRate-0.5.jpg width=200 height=200)

![Envelope: Cylindric](Envelope-Cylindric.jpg width=200 height=200) ![Envelope: Spherical](Envelope-Spherical.jpg width=200 height=200) ![Envelop: Conical](Envelope-Conical.jpg width=200 height=200)


Quality Results
==================================
![](branchesofacurvedtree.png)
 explaining what it demonstrates about your program's correctness and features 

![](orchard.png)
 explaining what it demonstrates about your program's correctness and features 

![](forest.png)
 explaining what it demonstrates about your program's correctness and features 


Evocative Result
==================================
![](evocativescene.png)


Schedule
==================================

Task                  | Description                                                |Date           | 
 ---------------------|------------------------------------------------------------|--------------:|
 Report Draft    (BDL)| Basic answers/placeholders inputted                        |     10/06     |   
 Code Draft      (BDL)| Code with basic format and structure done                  |     10/07     |  
 fix CFrame bug    (D)| Cylinders won't generate at an angle, fix                  |     10/08     |   
 fix floating tree bug (BD)| Branches are floating above their parents, fix        |     10/09     |  
 Add Leaves          (D)| Add leaf generation                                      |     10/10     |  
 Report MVP        (BDL)| Get to Report MVP                                        |     10/12     |  
 Add Space Colonization (B)| Add space colonization tree generation algorithm      |     10/14     |  
 Add realistic radius  (D)| Add realistic tree radius function                     |     10/13     |  
 Specific makeBranch functions | Write standard makeBranch and helper methods to create different tree "phenotypes" (L) | 10/13 |
 Generate OBJ files (D)| Write tree models in OBJ format in addition to OFF format |     10/13     |
 Add spine curve callback function | Add functionality to default spine curve function so our branches curve | 10/14 |
 Add branch sections functionality | Be able to determine how many sections in a branch |  10/14   |
 Add texture     (B)  | Map texture coordinates to leaves and branches             |     10/14     |
 Add bump map    (B)  | Map bump coordinates to leaves and branches                |     10/14     |
 Add GUI Functionality (L)| Add elements from specification to the GUI             |     10/14     |
 Add fruit trees (L)  | Write function to add fruits to a scene where they would be growing on a tree | 10/16 |
 Add tree skeleton for L-system (D)| Rewrote L-system algorithm to use Ben's Tree class| 10/17     |
 Add generate orchard (L)| Add function to generate orchards of fruit trees        |     10/18     |
 Make more phenotypes (D)| Write different callback functions to generate different looking trees | 10/18 |
 Make more spine curves (B)| Write different callback functions to generate trees with branches curving differently | 10/18 |
 Clean up code (B)    | Abstract methods into separate classes, add comments, fix bugs|  10/18     |

   
Change Log
==================================
1. Broke up L-system generation and space colonization generation into different classes - Ben, 10/18.
2. Modified L-system generation algorithm to use Ben's tree class - Diego, 10/17.
3. Added a new tree generation algorithm, **space colonization**, to the specification - Ben, 10/11.


<!-- Markdeep: -->
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace;}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>