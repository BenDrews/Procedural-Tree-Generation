                  <meta charset="utf-8">
                  **Report: Trees**
            Ben Drews, Diego Gonzalez, Lylia Li
            bfd2@williams.edu
            drg4@williams.edu
            ll5@williams.edu

![The beauty of computer graphics is making interesting models!](interestingTree.png)


Introduction 
==================================
Our program procedurally generates tree models that are made of cylinders connected to each other. Trees of different shapes and sizes can be generated by changing the length of child branches. A GUI provides additional options, such as calculating realistic branch radii and using different algorithms to actually produce the branches, that users can turn on and off to alter the tree models that are produced.


Specification
==================================
**Features of the program:**

1. A user interface with the following tabs:
    1. L-system tab
        1. Recursion depth: Number of levels of recursion we will take our L-system through
        2. Initial height of tree
        3. Circle points: How round the cylinders that make up the tree will be
        4. Branch sections: How many cylindric sections are added to each branch
        5. Phenotype: What type of tree is generated
        6. Generate button to run the program
    2. Space colonization tab
        1. Anchor count: Number of initial anchor points
        2. Height: Total height of the tree
        3. Radius: Radius of the area the anchor points will be generated in
        4. Circle points: How round the cylinders that make up the tree will be
        5. Distance between tree nodes
        6. Kill distance for anchor nodes
        7. Initial branch tip radius: Each branch radius is defined by the radii of its children, so we add a parameter to specify the radius of a branch with no children
        8. Branch radius growth factor: Specific constant in definition of branch radius used by space colonization algorithm; higher constants lead to slower growth
        9. Attraction radius: Radius within which anchor points can attract nodes
        10. Leafiness
        11. Generate button to run the program
    3. Orchard tab
        1. Number of rows in the orchard
        2. Trees per row of orchard
        3. Generation type: Whether we are using L-system or space colonization trees
        4. Fruit type: Drop down list to choose which fruit the tree grows
        5. Generate button to run the program

2. In all tabs, when the "Generate" button is pressed, the program:
    1. Immediately displays a waiting screen
    2. Generates a tree/orchard with the specificed parameters
    3. Saves the generated model/scene to a file and loads the scene

3. L-system tree generation entry points
    1. method `App::makeLSkeleton()`: Generates a tree skeleton based on an L-system, with the parameters specified in the GUI
    2. method `App::skeletonToMeshL`: Converts the generated tree skeleton to an OBJ mesh

4. Space colonization tree generation entry points
    1. method `App::makeSCSkeleton()`: Generates a tree skeleton based on the space colonization algorithm, with the parameters specified in the GUI
    2. method `App::skeletonToMeshSC`: Converts the generated tree skeleton to an OBJ mesh

5. Orchard generation entry points
    1. method `App::generateOrchard()`: Generates a Scene.Any file containing an orchard of fruit trees with the parameters specified in the GUI

**Program evaluation metric:**

- Graph the time it took to render a tree model versus the number of child branches with a set recursion depth of 7

- Graph the time it took to render a tree model versus the recursion depth with three child branches at each recursion.

- **TODO:: ADD EVALUATION METRIC FOR SPACE COLONIZATION MODEL**


**Quality images:**
![An orchard with trees growing fruits, and small differences between trees to show variations within a single phenotype.](design4.jpg)

![A forest populated with different phenotypes of trees, to show variations between the trees our algorithm can generate.](specificationforest.png)

**Evocative result:**

![A fantasy scene of different planets being overgrown by different, arbitrarily large trees.](design5.jpg)


Topic Overview 
==================================
**Tree Generation using L-Systems**

L-systems provide an easy way to generate plantlike structures. Nature often encorporates fractal patterns in how plants grow and branch, which translates easily into recursive method calls which mirror such growth on a mesh (1).

![Fractals in Nature](plantFractal.png)

In order to set up this generation, a set of simple recusive rules must be written. These generally replace or grow a set of smaller branches off of a parent branch, and can be applied repeatedly to get increasingly detailed results.

![Products of L-Systems](L-SystemProducts.jpg)

**Tree Generation using Space Colonization**

Space Colonization is an algorithm that attempts to model the competition by branches for space on a tree in its generation. It does a better job than L-Systems at modeling mature trees, since as plant mature, the factors limiting their growth start to weigh more heavily on how branches are placed than the factors creating opportunites for growth (2).

![Tree generated with Space Colonization](SpaceColonizationTree.jpg)

The algorithm works by randomly seeding a volume with anchor points, which pull on tree nodes, spawning adjacent tree nodes in the average direction of the anchor points pulling on that node. Once a tree node gets too close to an anchor node, than anchor is destroyed. This process repeats until all anchors are destroyed.

![Space Colonization Iteration](SpaceColIter.jpg)


**Works Cited**

1. “L-system,” *Wikipedia*, accessed 19 Oct 2016. https://en.wikipedia.org/wiki/L-system

2. Adam Runions, Brendan Lane, and Przemyslaw Prusinkiewicz, “Modeling Trees with a Space Colonization Algorithm,” Eurographics Workshop on Natural Phenomena (2007). http://algorithmicbotany.org/papers/colonization.egwnp2007.pdf

Design
==================================

![](calldiagram.jpg)


**TODO:: ADD HYPERLINK TO DOXYGEN DOCUMENTATION**

**Major functions of App**
 Function             | Description                                                
 ---------------------|------------------------------------------------------------
 makeTree             | Creates Meshes for the tree and the leaves of the tree, initializes the length of the “trunk” of the tree, and calls makeBranch
 makeBranch           | Recursively adds branches to a tree mesh, and calls addLeaves when recursionDepth is zero
 addCylindricSection  | Given a Mesh and an initial circle, adds an additional circle to the mesh underneath the initial circle and adds faces between the circles
 addLeaves            | Given a Mesh, adds a two-sided triangle to the Mesh
 generateAnchorPoints | returns a randomly distributed set of points inside the volume specified by the `envelopePerimeter` parameter
 findClosestAnchor    | returns an array of the closest anchor points to each tree node that is within the radius of attraction
 findGrowthDirections | returns a map from the trees that have an anchor point within the radius of attraction to the average direction from that tree node to all anchors attracting it


**Major functions of Mesh**
 Function             | Description                                                
 ---------------------|------------------------------------------------------------
 addVertex            | Adds a vertex to the Mesh
 addFace              | Adds a face (three indices of the vertices array) to the Mesh
 numVertices          | Returns the size of the vertices array
 addMesh              | Adds a given Mesh to the end of the current Mesh
 toOFF                | Writes the Mesh to an OFF file
 toOBJ                | Writes the Mesh to an OBJ file

**Major functions of Face**
 Function             | Description                                                
 ---------------------|------------------------------------------------------------
 increment            | Increments all of the points of the face by a given number


Our program has four main functions: makeTree, makeBranch, addCylindricSection, and addLeaves. The makeTree function initializes the Meshes for the body of the tree and the leaves of the tree, and calls makeBranch to add cylinders to the Mesh. makeBranch is given a recursion depth that is decremented each time it is called. When the recursion depth is zero, it calls addLeaves to add leaves to the end of the current branch instead of constructing a new branch. addCylindricSection is a helper method for constructing cylinders that adds a circle underneath an initial circle. This design makes sense because we can see the initial parameters of the tree we are making by looking at the makeTree method call, and without having to see the details of how the tree is constructed in makeBranch. Also, this will allow us to have different makeBranch methods in order to generate trees of different phenotypes.

To handle the logic of adding vertices and faces to a Mesh and writing the Mesh to a file in OFF format, we used Ben’s Mesh class from the Meshes lab. A `Vector` of `Point3`s is used to store the vertices and a `Vector` of `Poly`s, which are `SmallArray`s of three `int`s, is used to store the faces. This way, we do not have to write OFF files of generated trees directly in our App class, which would make things messy and bulky.

**TODO:: WRITE DESCRIPTION OF FACE CLASS**


Correctness Results
==================================
demonstrating that the program is working as intended (or not), as dictated by your specification. These will probably be on very simple cases that can be hand-verified or are self-evidently correct. Explain why these are good and nearly-comprehensive tests. The results are frequently images in graphics projects, but may also be other forms of data.

![Wireframe of leafless tree](leafless.png)

![Same tree as above with leaves](leafful.png)

![Tree #1 with L-system generation](gTree1.png)

![Tree #2 with L-system generation](gTree2.png)

![Tree #3 with L-system generation](gTree3.png)


![Wireframe of leafless tree to demonstrate proper branch generation](tree1.png)

The default parameters for the L-system tree are as follows:

1. Recursion Depth = 4
2. Phenotype = Normal
3. Spine Curve = Straight

![Recursion Depth: 5](RecursionDepth-5.jpg width=200 height=200) ![Recursion Depth: 6](RecursionDepth-6.jpg width=200 height=200) ![Recursion Depth: 7](RecursionDepth-7.jpg width=200 height=200)

![Phenotype: Random](Phenotype-Random.jpg width=200 height=200) ![Phenotype: Bush](Phenotype-Bush.jpg width=200 height=200) ![Phenotype: Pine](Phenotype-Pine.jpg width=200 height=200)

![Spine Curve: Curvy](SpineCurve-Curvy.jpg width=200 height=200) ![Spine Curve: Corkscrew](SpineCurve-Corkscrew.jpg width=200 height=200) ![Spine Curve: ](SpineCurve-Curvy.jpg width=200 height=200)

The default parameters for the space colonization tree are as follows:

1. Anchor Points = 1000
2. Tree Node Distance = 0.5
3. Kill Distance = 2
4. Initial Branch Radius = 0.01
5. Radius Growth Factor = 2
6. Attraction Radius = 100
7. Leafiness = 10
8. Discount Rate = 0.9
9. Envelope = Bulb

![Default Tree](Default-SC.jpg width=600)

These images show the effect of varying each parameter on the default tree:

![Anchor Points: 100](AnchorPoints-100.jpg width=200 height=200) ![Anchor Points: 500](AnchorPoints-500.jpg width=200 height=200) ![Anchor Points: 5000](AnchorPoints-5000.jpg width=200 height=200)

![Node Distance: 0.1](NodeDistance-0.1.jpg width=200 height=200) ![Node Distance: 0.25](NodeDistance-0.25.jpg width=200 height=200) ![Node Distance: 1](NodeDistance-1.jpg width=200 height=200)

![Kill Distance: 0.5](KillDistance-0.5.jpg width=200 height=200) ![Kill Distance: 1](KillDistance-1.jpg width=200 height=200) ![Kill Distance: 5](KillDistance-5.jpg width=200 height=200)

![Initial Radius: 0.025](InitialRadius-0.025.jpg width=200 height=200) ![Initial Radius: 0.05](InitialRadius-0.05.jpg width=200 height=200) ![Initial Radius: 0.1](InitialRadius-0.1.jpg width=200 height=200)

![Radius Growth Factor: 2.25](RadiusGrowthFactor-2.25.jpg width=200 height=200) ![Radius Growth Factor: 2.5](RadiusGrowthFactor-2.5.jpg width=200 height=200) ![Radius Growth Factor: 3](RadiusGrowthFactor-3.jpg width=200 height=200)

![Attraction Radius: 5](AttractionRadius-5.jpg width=200 height=200) ![Attraction Radius: 10](AttractionRadius-10.jpg width=200 height=200) ![Attraction Radius: 50](AttractionRadius-50.jpg width=200 height=200)

![Leafiness: 1](Leafiness-1.jpg width=200 height=200) ![Leafiness: 2](Leafiness-2.jpg width=200 height=200) ![Leafiness: 5](Leafiness-5.jpg width=200 height=200)

![Discount Rate: 0](DiscountRate-0.jpg width=200 height=200) ![Discount Rate: 0.25](DiscountRate-0.25.jpg width=200 height=200) ![Discount Rate: 0.5](DiscountRate-0.5.jpg width=200 height=200)

![Envelope: Cylindric](Envelope-Cylindric.jpg width=200 height=200) ![Envelope: Spherical](Envelope-Spherical.jpg width=200 height=200) ![Envelop: Conical](Envelope-Conical.jpg width=200 height=200)


Quality Results
==================================
![](branchesofacurvedtree.png)
 explaining what it demonstrates about your program's correctness and features 

![](orchard.png)
 explaining what it demonstrates about your program's correctness and features 

![](forest.png)
 explaining what it demonstrates about your program's correctness and features 


Evocative Result
==================================
![](planets.png)


Schedule
==================================

Task                  | Description                                                |Date           | 
 ---------------------|------------------------------------------------------------|--------------:|
 Report Draft    (BDL)| Basic answers/placeholders inputted                        |     10/06     |   
 Code Draft      (BDL)| Code with basic format and structure done                  |     10/07     |  
fix CFrame bug     (D)| Cylinders won't generate at an angle, fix                  |     10/08     |   
fix floating tree bug (BD)| Branches are floating above their parents, fix         |     10/09     |  
 Add Leaves          (D)| Add leaf generation                                      |     10/10     |  
 Report MVP        (BDL)| Get to Report MVP                                        |     10/12     |  
 Add Space Colonization (B)| Add space colonization tree generation algorithm      |     10/14     |  
 Add realistic radius  (D)| Add realistic tree radius function                     |     10/13     |  
 Specific makeBranch functions | Write standard makeBranch and helper methods to create different tree "phenotypes" (L) | 10/13 |
 Generate OBJ files (D)| Write tree models in OBJ format in addition to OFF format |     10/13     |
 Add spine curve callback function | Add functionality to default spine curve function so our branches curve | 10/14 |
 Add branch sections functionality | Be able to determine how many sections in a branch |  10/14   |
 Add texture     (B)  | Map texture coordinates to leaves and branches             |     10/14     |
 Add bump map    (B)  | Map bump coordinates to leaves and branches                |     10/14     |
 Add GUI Functionality (L)| Add elements from specification to the GUI             |     10/14     |

 
   
Change Log
==================================
1. Added a new tree generation algorithm, **space colonization**, to the specification - Ben, 10/11.


<!-- Markdeep: -->
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace;}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>