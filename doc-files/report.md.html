                  <meta charset="utf-8">
                  **Report: Trees**
            Ben Drews, Diego Gonzalez, Lylia Li
            bfd2@williams.edu
            drg4@williams.edu
            ll5@williams.edu

![The beauty of computer graphics is making interesting models!](interestingTree.png)


Introduction 
==================================
Our program procedurally generates tree models that are made of cylinders connected to each other. Trees of different shapes and sizes can be generated by changing the length of child branches. A GUI provides additional options, such as calculating realistic branch radii and using different algorithms to actually produce the branches, that users can turn on and off to alter the tree models that are produced.


Specification
==================================
1. A user interface with the following controls:
    1. Integer number box for the max recursion depth
    2. Slider to use L-system generation or Space Colonization generation
    3. Tree phenotype dropdown list
    4. Generate button to start the generation 

2. When the "Generate" button is pressed, the program:
    1. Immediately displays a waiting screen
    2. Generates the tree
    3. Places it into the "tree testing" scene and loads that scene

3. Tree Generation
    1. makeTree function that starts the generation
    2. makeBranch function that adds a branch to the tree. Different functions can be made for different tree phenotypes.
    3. Mesh class that stores all the vertices and faces. This class also handles the actual file generation.
    4. makeCylindricSection function that adds a cylinder in a given coordinate frame to the Mesh.
    5. makeLeaves function that adds leaves to a second mesh object.

4. Output two OFF files, one for the tree branches, and one for the tree leaves.

Program Evaluation Metric:
- Graph the time it took to render a tree model versus the number of child branches with a set recursion depth of 7
- Graph the time it took to render a tree model versus the recursion depth with three child branches at each recursion.

![Wireframe of leafless tree to demonstrate proper branch generation](tree1.png)

Three different tree phenotypes created with the same generation algorithm:
![](tree2.jpg)
![](tree3.jpg)
![](tree4.jpg)


Topic Overview 
==================================
**Tree Generation using L-Systems**

[L-Systems](https://en.wikipedia.org/wiki/L-system) provide an easy way to generate plantlike structures. Nature often encorporates fractal patterns in how plants grow and branch, which translates easily into recursive method calls which mirror such growth on a mesh.

![Fractals in Nature](plantFractal.png)

In order to set up this generation, a set of simple recusive rules must be written. These generally replace or grow a set of smaller branches off of a parent branch, and can be applied repeatedly to get increasingly detailed results.

![Products of L-Systems](L-SystemProducts.jpg)

**Tree Generation using Space Colonization**

[Space Colonization](http://algorithmicbotany.org/papers/colonization.egwnp2007.pdf) is an algorithm that attempts to model the competition by branches for space on a tree in its generation. It does a better job than L-Systems at modeling mature trees, since as plant mature, the factors limiting their growth start to weigh more heavily on how branches are placed than the factors creating opportunites for growth.

![Tree generated with Space Colonization](SpaceColonizationTree.jpg)

The algorithm works by randomly seeding a volume with anchor points, which pull on tree nodes, spawning adjacent tree nodes in the average direction of the anchor points pulling on that node. Once a tree node gets too close to an anchor node, than anchor is destroyed. This process repeats until all anchors are destroyed.

![Space Colonization Iteration](SpaceColIter.jpg)


Design
==================================

![](calldiagram.png)


**TODO:: ADD HYPERLINK TO DOXYGEN DOCUMENTATION**

**Major Functions of App**
 Function             | Description                                                
 ---------------------|------------------------------------------------------------
 makeTree             | Creates Meshes for the tree and the leaves of the tree, initializes the length of the “trunk” of the tree, and calls makeBranch
 makeBranch           | Recursively adds branches to a tree mesh, and calls addLeaves when recursionDepth is zero
 addCylindricSection  | Given a Mesh and an initial circle, adds an additional circle to the mesh underneath the initial circle and adds faces between the circles
 addLeaves            | Given a Mesh, adds a two-sided triangle to the Mesh

**Major Functions of Mesh**
 Function             | Description                                                
 ---------------------|------------------------------------------------------------
 addVertex            | Adds a vertex to the Mesh
 addFace              | Adds a face (three indices of the vertices array) to the Mesh
 numVertices          | Returns the size of the vertices array
 toOFF                | Writes the Mesh to an OFF file


Our program has four main functions: makeTree, makeBranch, addCylindricSection, and addLeaves. The makeTree function initializes the Meshes for the body of the tree and the leaves of the tree, and calls makeBranch to add cylinders to the Mesh. makeBranch is given a recursion depth that is decremented each time it is called. When the recursion depth is zero, it calls addLeaves to add leaves to the end of the current branch instead of constructing a new branch. addCylindricSection is a helper method for constructing cylinders that adds a circle underneath an initial circle. This design makes sense because we can see the initial parameters of the tree we are making by looking at the makeTree method call, and without having to see the details of how the tree is constructed in makeBranch. Also, this will allow us to have different makeBranch methods in order to generate trees of different phenotypes.

To handle the logic of adding vertices and faces to a Mesh and writing the Mesh to a file in OFF format, we used Ben’s Mesh class from the Meshes lab. A `Vector` of `Point3`s is used to store the vertices and a `Vector` of `Poly`s, which are `SmallArray`s of three `int`s, is used to store the faces. This way, we do not have to write OFF files of generated trees directly in our App class, which would make things messy and bulky.


Correctness Results
==================================
![Wireframe of leafless tree](leafless.png)

![Same tree as above with leaves](leafful.png)

![Tree #1 with L-system generation](gTree1.png)

![Tree #2 with L-system generation](gTree2.png)

![Tree #3 with L-system generation](gTree3.png)

Quality Results
==================================
**Polish Goals**

For polish, we will map bark textures to our trees.

We also want the branches of our trees to be smoothly connected:

![](curvegoals.jpg)

Evocative Result
==================================
For our custom scene, we would like to make an orchard with trees that grow different things. For example, we could have an apple tree, a money tree, a teapot tree, and a wine glass tree in our orchard. This will show the variation between same "species" of procedurally generated trees.

![](design4.jpg)

Additionally, we would like to make a forest of all types of different trees.

Finally, we think it would be cool to make trees with roots that are mapped to the surface of a sphere, or planet, like in the Little Prince.

![](design5.jpg)

Self Evaluation
==================================
We deserve an A on the project. Our workflow was excellent and we reached MVP on our project within 2 days of work. This gave us a lot of time to polish and add interesting features to our program. We were able to address all of our MVP specification goals. Our code is clear, readable, and well-structured. We all learned a lot about tree generating algorithms and how the shapes of trees can be described mathematically.

Schedule
==================================
2016-10-11: MVP code - Ben, Diego, Lylia
2016-10-13: MVP report
    - Topic overview: Ben
    - Introduction, design: Lylia
    - Specification, results: Diego
2016-10-13: Implementation of space colonization algorithm - Ben

Task                  | Description                                                |Date           | 
 ---------------------|------------------------------------------------------------|--------------:|
 Report Draft    (BDL)| Basic answers/placeholders inputted                        |     10/06     |   
 Code Draft      (BDL)| Code with basic format and structure done                  |     10/07     |  
fix CFrame bug     (D)| Cylinders won't generate at an angle, fix                  |     10/08     |   
fix floating tree bug (BD)| Branches are floating above their parents, fix         |     10/09     |  
 Add Leaves          (D)| Add leaf generation                                      |     10/10     |  
 Report MVP        (BDL)| Get to Report MVP                                        |     10/12     |  
 Add Space Colonization(B)| Add space colonization tree generation algorithm       |     10/13     |  
 Add realistic radius  (D)| Add realistic tree radius function                     |     10/13     |  
 Add GUI Functionality (L)| Add elements from specification to the GUI             |     10/13     |  

   
Change Log
==================================
1. Added a new tree generation algorithm, **space colonization**, to the specification - Ben, 10/11.


<!-- Markdeep: -->
<style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace;}</style><script src="https://casual-effects.com/markdeep/latest/markdeep.min.js"></script><script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>